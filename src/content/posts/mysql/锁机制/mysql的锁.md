---
title: mysql的锁
published: 2025-12-30
description: ''
image: '../cover.png'
tags: ["mysql"]
category: 'mysql'
draft: false 
lang: ''
---
# MySQL中的锁类型：
在 MySQL 中，主要有以下几种锁类型：

**锁粒度**：

1）行级锁（Row Lock）（重点）：

锁的是索引上的纪录，允许其他事务并发访问不同的行，适用于高并发场景。

2）表级锁（Table Lock）（重点）：

对整个表加锁，其他事务无法对该表进行任何读写操作，适用于需要保证完整性的小型表。

3）意向锁（Intention Lock）：

一种表锁，用于表示某个事务即将在某行数据上加S锁或者X锁，这样当别的事务加表级锁时，只需要检查表有没有IS和IX,而不用遍历整张表（解决行锁和表锁冲突的性能问题）。

**锁模式**：

4）共享锁（Shared Lock）（重点）：

允许多个事务并发读取同一资源，但不允许修改。只有在释放共享锁后，其他事务才能获得排它锁。
**加锁语句： SELECT xxx from xxx LOCK IN SHARE MODE**;

5）排它锁（Exclusive Lock）（重点）：

只允许一个事务对资源进行读写，其他事务在获得排它锁之前无法访问该资源。

● **加锁语句:** SELEC T xxx from xxx FOR UPDATE;

● 对数据进行更新的时候，也就是**INSERT、DELETE或者UPDATE**的时候，数据库也会自动使用排它锁，防止其事务对该数据行进行操作。

**解决并发和幻读问题**：

6）记录锁

记录锁是作用于索引上的锁，用于**锁住当前记录**。InnoDB 即便无主键也会创建隐藏聚簇索引，故记录锁始终锁定索引记录。

例如事务 A 执行 SELECT * FROM yes WHERE name = 'xx' FOR UPDATE; 会锁定 name = xx 这条记录，其他事务无法对其进行插入、删除、修改操作。

当事务 A 未提交时，另一事务 B 执行 insert into table (name) values ('xx') 会被阻塞。而事务 C 执行 insert into table (name) values ('aa') 是否阻塞取决于 name 字段：

若 name 没有索引，由于记录锁需作用于索引，此时只能依赖聚簇索引，但聚簇索引无法通过 name 快速定位数据，需全表扫描，最终导致整个表被锁定，所以事务 C 会被阻塞。
若 name 有索引，事务 C 不会被阻塞。（也就是行锁依赖索引，如果没有索引会升级为表锁）
综上，没有索引的列不要随意进行锁定操作 。

7）间隙锁（Gap Lock）（重点）：

针对索引中两个记录之间的间隙加锁，防止其他事务在这个间隙中插入新记录，以避免幻读。间隙锁不锁定具体行，而是锁定行与行之间的空间。

8）临键锁（Next-Key Lock）（重点）：

是纪录锁锁和间隙锁的结合，锁定具体行和其前面的间隙，常用于**支持可重复读的隔离级别**。

**其他两个特殊锁**：

9）元数据锁（Metadata Lock, MDL）：

用于保护数据库对象（如表和索引）的元数据，防止在进行 DDL 操作和DML操作的冲突问题。

10）自增锁（Auto Increment Lock）：

在插入自增列时，加锁以保证自增值的唯一性。通常在插入操作时被使用，以确保生成的自增 ID 是唯一的。

## 锁的触发 & 降级 / 升级
### 临键锁 3 种降级场景
唯一索引精准等值查询，命中则降级为记录锁，未命中降级为间隙锁

唯一索引范围查询，不会降级，全程临键锁

非唯一索引等值查询，仅降级部分，保留记录锁 + 间隙锁

### 行锁升级为表锁的 2 种情况
查询 / 更新未命中任何索引（InnoDB 无法精准定位行）

批量更新（如 update 全表），InnoDB 会主动升级为表锁提升效率
